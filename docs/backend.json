{
  "entities": {
    "Event": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Event",
      "type": "object",
      "description": "Represents an event available for ticket booking.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the event."
        },
        "name": {
          "type": "string",
          "description": "Name of the event."
        },
        "date": {
          "type": "string",
          "description": "Date of the event.",
          "format": "date-time"
        },
        "time": {
          "type": "string",
          "description": "Time of the event."
        },
        "venue": {
          "type": "string",
          "description": "Venue of the event."
        },
        "description": {
          "type": "string",
          "description": "Description of the event."
        }
      },
      "required": [
        "id",
        "name",
        "date",
        "time",
        "venue",
        "description"
      ]
    },
    "TicketCategory": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TicketCategory",
      "type": "object",
      "description": "Represents a category of tickets for an event (e.g., VIP, Normal).",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the ticket category."
        },
        "eventId": {
          "type": "string",
          "description": "Reference to Event. (Relationship: Event 1:N TicketCategory)"
        },
        "name": {
          "type": "string",
          "description": "Name of the ticket category (e.g., VIP, Normal)."
        },
        "price": {
          "type": "number",
          "description": "Price of a ticket in this category."
        },
        "limit": {
          "type": "number",
          "description": "Maximum number of tickets available in this category."
        }
      },
      "required": [
        "id",
        "eventId",
        "name",
        "price",
        "limit"
      ]
    },
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user of the system.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the user."
        },
        "name": {
          "type": "string",
          "description": "Full name of the user."
        },
        "email": {
          "type": "string",
          "description": "Email address of the user.",
          "format": "email"
        },
        "verified": {
          "type": "boolean",
          "description": "Indicates whether the user's ID has been verified by an admin."
        },
        "isAdmin": {
          "type": "boolean",
          "description": "Indicates whether the user has admin privileges."
        }
      },
      "required": [
        "id",
        "name",
        "email",
        "verified",
        "isAdmin"
      ]
    },
    "Booking": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Booking",
      "type": "object",
      "description": "Represents a ticket booking made by a user.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the booking."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Booking)"
        },
        "ticketCategoryId": {
          "type": "string",
          "description": "Reference to TicketCategory. (Relationship: TicketCategory 1:N Booking)"
        },
        "bookingDate": {
          "type": "string",
          "description": "Date when the booking was made.",
          "format": "date-time"
        },
        "numberOfTickets": {
          "type": "number",
          "description": "Number of tickets booked."
        }
      },
      "required": [
        "id",
        "userId",
        "ticketCategoryId",
        "bookingDate",
        "numberOfTickets"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/events/{eventId}",
        "definition": {
          "entityName": "Event",
          "schema": {
            "$ref": "#/backend/entities/Event"
          },
          "description": "Stores event details. Admin users have full access. Users have read access.",
          "params": [
            {
              "name": "eventId",
              "description": "Unique identifier for the event."
            }
          ]
        }
      },
      {
        "path": "/events/{eventId}/ticketCategories/{ticketCategoryId}",
        "definition": {
          "entityName": "TicketCategory",
          "schema": {
            "$ref": "#/backend/entities/TicketCategory"
          },
          "description": "Stores ticket categories for an event. Includes 'eventId' to identify the parent event.",
          "params": [
            {
              "name": "eventId",
              "description": "Unique identifier for the event."
            },
            {
              "name": "ticketCategoryId",
              "description": "Unique identifier for the ticket category."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user information. Only the user and admins have full access.",
          "params": [
            {
              "name": "userId",
              "description": "Unique identifier for the user."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/bookings/{bookingId}",
        "definition": {
          "entityName": "Booking",
          "schema": {
            "$ref": "#/backend/entities/Booking"
          },
          "description": "Stores booking details for a user. Includes 'userId' and 'ticketCategoryId' for relationship mapping. The 'userId' is denormalized for authorization independence.",
          "params": [
            {
              "name": "userId",
              "description": "Unique identifier for the user."
            },
            {
              "name": "bookingId",
              "description": "Unique identifier for the booking."
            }
          ]
        }
      },
      {
        "path": "/roles_admin/{userId}",
        "definition": {
          "entityName": "roles_admin",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Documents in this collection indicate admin role. Existence of document confers admin rights.",
          "params": [
            {
              "name": "userId",
              "description": "Unique identifier for the user with admin privileges."
            }
          ]
        }
      }
    ],
    "reasoning": "This Firestore structure is designed to support TicketSwift's event ticket booking system, prioritizing security, scalability, and debuggability. It follows the core design principles of Authorization Independence, Clarity of Intent, DBAC (Database-Based Access Control), and QAPs (Rules are not Filters).\n\n**Authorization Independence**: Achieved through denormalization of data, specifically within the `bookings` subcollection under each `ticketCategory`. Each `booking` document contains the `userId` which eliminates the need to `get()` the `user` document for authorization. This allows atomic operations and simplifies security rules.\n\n**Structural Segregation**: The structure segregates data with different access needs into distinct collections.  User data is stored under `/users/{userId}`, event data under `/events/{eventId}`, and ticket categories under `/events/{eventId}/ticketCategories/{ticketCategoryId}`. This segregation allows for simpler and more targeted security rules.\n\n**Access Modeling**: The structure leverages path-based ownership for user-owned data (e.g., `/users/{userId}/bookings/{bookingId}`) and the subcollection pattern for entities with `1:N` relationships (e.g., Event has many TicketCategories).  Since there is no concept of 'collaborative data' in this application, membership maps are not used.  Admin roles are handled by checking for the existence of documents in the `/roles_admin/{uid}` collection.\n\n**QAPs (Rules are not Filters)**: The structure enables secure `list` operations by avoiding the need to filter based on user roles or permissions within the query itself.  For example, listing events does not require filtering based on user role; instead the application filters events appropriate to the user's role based on the path requested by the client. Authorization Independence ensures that rules can validate access without needing to read other documents. Segregation further prevents filtering based on complex expressions.\n\n**Additional Considerations**:\n*   The `verified` field in the `/users/{userId}` document allows the admin to verify a user. All events and tickets are visible, but booking is only allowed for verified users.\n*   The structure facilitates querying for events, ticket categories, and bookings based on relevant criteria (e.g., events by date, ticket categories by event ID, bookings by user ID).\n*   The structure can scale horizontally by adding more Firestore instances as needed.\n*   Auditing can be implemented by logging all actions (login attempts, ticket operations, admin actions) to a separate audit log collection."
  }
}