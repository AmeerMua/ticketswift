/**
 * This ruleset enforces a security model with two primary roles: Users and Admins.
 * - Core Philosophy: The default posture is to deny all access. Rules then grant specific
 *   permissions. Admins, identified by the `isAdmin` flag on their user document, have
 *   broad access for management. Regular users have restricted access, primarily to their
 *   own data and public information.
 * - Data Structure: Data is organized into a top-level public `/events` collection and a
 *   user-private `/users` collection. Each user's data, including their bookings, is
 *   nested under their unique user ID (`/users/{userId}`), creating a clear ownership hierarchy.
 * - Key Security Decisions:
 *   - Admin access is managed via an `isAdmin` boolean field on the user's own document.
 *   - User enumeration is prevented by disallowing `list` operations on the top-level `/users` collection.
 *   - Public data like events and ticket categories is readable by anyone, but writable only by admins.
 *   - A critical business rule is enforced: only users with `verified == true` on their user
 *     document can create new bookings, and each booking is limited to 3 tickets.
 * - Denormalization for Authorization: The `userId` is denormalized onto `Booking` documents.
 *   This allows security rules on the `/users/{userId}/bookings/{bookingId}` path to authorize
 *   requests by checking the document's `userId` field against the user's auth token, without
 *   needing extra database reads.
 * - Structural Segregation: Public data (`/events`) is stored separately from user-specific
 *   private data (`/users`). This separation simplifies rules and improves query performance.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Checks if the currently authenticated user's UID matches the given userId.
     * This is the foundation for the ownership model.
     * @param userId The user ID to check against.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * Checks if the requesting user has an admin role.
     * Admin status is conferred by the `isAdmin` flag on their user document.
     */
    function isAdmin() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isAdmin == true;
    }

    /**
     * Checks if the user's profile document has the 'verified' flag set to true.
     * This requires a single document read and is used to authorize booking creation.
     */
    function isVerifiedUser() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.verified == true;
    }

    /**
     * Enforces the business rule that a single booking cannot contain more than 3 tickets.
     */
    function isBookingWithinTicketLimit() {
      return request.resource.data.numberOfTickets <= 3;
    }

    /**
     * On user profile update, ensures a non-admin user cannot change their own 'verified' or 'isAdmin' status.
     * Allows the update if the fields are not in the request, or if they are present but unchanged.
     */
    function isNotChangingSensitiveFields() {
      let isVerifiedUnchanged = !('verified' in request.resource.data) || (request.resource.data.verified == resource.data.verified);
      let isAdminUnchanged = !('isAdmin' in request.resource.data) || (request.resource.data.isAdmin == resource.data.isAdmin);
      return isVerifiedUnchanged && isAdminUnchanged;
    }


    /**
     * On user document creation, ensures the document's internal 'id' field
     * matches the document's ID from the path, establishing the ownership link.
     */
    function hasValidUserIdOnCreate(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * On booking creation, ensures the booking's internal 'userId' field
     * matches the user's ID from the path, establishing the ownership link.
     */
    function hasValidBookingUserIdOnCreate(userId) {
      return request.resource.data.userId == userId;
    }
    
    /**
     * On booking update, ensures a regular user is only changing the 'status' to 'Cancelled'.
     * This prevents users from confirming their own bookings or changing other details.
     */
    function isOnlyCancellingBooking() {
      let nextData = request.resource.data;
      let currentData = resource.data;
      // Check that the new status is 'Cancelled' and the old one was not.
      return nextData.status == 'Cancelled' 
             && currentData.status != 'Cancelled'
             // Use affectedKeys() to ensure ONLY the 'status' field is being changed.
             && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status']);
    }

    // ----------------------------------------------------------------------
    // Collection Rules
    // ----------------------------------------------------------------------

    /**
     * @description Publicly readable event information. Only admins can create, modify, or delete events.
     * @path /events/{eventId}
     * @allow (get, list) Any user, signed in or not, can read event data.
     * @deny (create) A non-admin user attempts to create a new event.
     * @principle Segregates public data and restricts write access to privileged roles.
     */
    match /events/{eventId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();

      /**
       * @description Ticket categories for an event. Stored within the event document, so this rule is redundant but kept for clarity.
       * @path /events/{eventId}/ticketCategories/{ticketCategoryId}
       * @allow (get, list) Any user can read the ticket categories for an event.
       * @deny (create) A regular signed-in user attempts to add a new ticket category.
       * @principle Enforces consistent security on nested data that shares the same access requirements as its parent.
       */
      match /ticketCategories/{ticketCategoryId} {
        allow get, list: if true;
        allow create, update, delete: if isAdmin();
      }
    }

    /**
     * @description User profile documents. Users can create and manage their own profile. Admins have override access.
     * @path /users/{userId}
     * @allow (create) A new user with uid 'user123' creates their own document at `/users/user123`.
     * @deny (list) Any user attempts to list all documents in the `/users` collection.
     * @deny (update) A user tries to change their own `verified` status from false to true.
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin(); // Only admins can list users
      allow create: if isOwner(userId) && hasValidUserIdOnCreate(userId);
      allow update: if (isOwner(userId) && isNotChangingSensitiveFields()) || isAdmin();
      allow delete: if isOwner(userId) || isAdmin();

      /**
       * @description A user's ticket bookings. Only the user who owns the booking can manage it.
       * @path /users/{userId}/bookings/{bookingId}
       * @allow (create) A verified user with uid 'user123' creates a new booking under their own path.
       * @deny (create) A user whose profile has `verified: false` attempts to create a booking.
       * @deny (get) User 'user456' attempts to read a booking belonging to 'user123'.
       * @principle Enforces document ownership and applies business logic for write operations.
       */
      match /bookings/{bookingId} {
        allow get, list: if isOwner(userId) || isAdmin();
        allow create: if isOwner(userId) && isVerifiedUser() && hasValidBookingUserIdOnCreate(userId) && isBookingWithinTicketLimit();
        allow update: if isAdmin() || (isOwner(userId) && isOnlyCancellingBooking());
        allow delete: if isOwner(userId) || isAdmin();
      }
    }
    
    /**
     * @description Audit logs for tracking important actions.
     * @path /audit_logs/{logId}
     * @allow (create) An authenticated user can create their own log entries.
     * @allow (read, write) Only admins can read or modify audit logs.
     * @principle Ensures users can log their actions, but cannot read or tamper with the audit trail.
     */
    match /audit_logs/{logId} {
      allow read, update, delete, list: if isAdmin();
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
    }
  }
}
